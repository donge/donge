<blockquote dir=\"ltr\" style=\"MARGIN-RIGHT: 0px\"><p><br />    Visual C++ Compiler Options可以指定的Calling Convention有 3种：<br />    /Gd /Gr /Gz<br /><br />    这三个参数决定了：<br /><br />    1.函数参数以何种顺序入栈，右到左还是左到右。<br />    2.在函数运行完后，是调用函数还是被调用函数清理入栈的参数。<br />    3.在编译时函数名字是如何转换的。<br /><br />    下面我们分别详细介绍：<br /><br />    1./Gd<br />        这是编译器默认的转换模式，对一般函数使用 C的函数调用转换方式__cdecl，<br />        但是对于C++ 成员函数和前面修饰了__stdcall __fastcall的函数除外。<br /><br />    2./Gr<br />        对于一般函数使用__fastcall函数调用转换方式，所有使用__fastcall的函数<br />        必须要有函数原形。但对于C++ 成员函数和前面修饰了__cdecl __stdcall 的函数除外。<br /><br />    3./Gz<br />        对于所有 C函数使用__stdcall函数调用转换方式，但对于可变参数的 C函数以<br />        及用__cdecl __fastcall修饰过的函数和C++ 成员函数除外。所有用__stdcall<br />        修饰的函数必须有函数原形。<br /><br />        事实上，对于x86系统，C++ 成员函数的调用方式有点特别，将成员函数的this<br />        指针放入ECX，所有函数参数从右向左入栈，被调用的成员函数负责清理入栈的<br />        参数。对于可变参数的成员函数，始终使用__cdecl的转换方式。<br /><br />    下面该进入主题，分别讲一下这三种函数调用转换方式有什么区别：<br /><br />    1.__cdecl<br />        这是编译器默认的函数调用转换方式，它可以处理可变参数的函数调用。参数<br />        的入栈顺序是从右向左。在函数运行结束后，由调用函数负责清理入栈的参数。<br />        在编译时，在每个函数前面加上下划线(_)，没有函数名大小写的转换。即<br />                　　_functionname<br /><br />    2.__fastcall<br />        有一些函数调用的参数被放入ECX，EDX中，而其它参数从右向左入栈。被调用<br />        函数在它将要返回时负责清理入栈的参数。在内嵌汇编语言的时候，需要注意<br />        寄存器的使用，以免与编译器使用的产生冲突。函数名字的转换是：<br />                　　@functionname@number<br />        没有函数名大小写的转换，number表示函数参数的字节数。由于有一些参数不<br />        需要入栈，所以这种转换方式会在一定程度上提高函数调用的速度。<br /><br />    3.__stdcall<br />    　　函数参数从右向左入栈，被调用函数负责入栈参数的清理工作。函数名转换格<br />    　　式如下：<br />        　　　　    _functionname@number<br /><br />    下面我们亲自写一个程序，看看各种不同的调用在编译后有什么区别，我们的被调<br />    用函数如下：<br /><br />    int function(int a, int b)<br />    &leftsign;<br />        return a + b;<br />    &rightsign;<br /><br />    void main()<br />    &leftsign;<br />        function(10, 20);<br />    &rightsign;<br /><br />    1.__cdecl<br /><br />        _function<br />                 push    ebp<br />                 mov     ebp, esp<br />                 mov     eax, [ebp+8]       ;参数1<br />                 add     eax, [ebp+C]       ;加上参数2<br />                 pop     ebp<br />                 retn<br />        _main<br />                 push    ebp<br />                 mov     ebp, esp<br />                 push    14h                ;参数 2入栈<br />                 push    0Ah                ;参数 1入栈<br />                 call    _function          ;调用函数<br />                 add     esp, 8             ;修正栈<br />                 xor     eax, eax<br />                 pop     ebp<br />                 retn<br /><br />    2.__fastcall<br /><br />        @function@8<br />                 push    ebp<br />                 mov     ebp, esp           ;保存栈指针<br />                 sub     esp, 8             ;多了两个局部变量<br />                 mov     [ebp-8], edx       ;保存参数 2<br />                 mov     [ebp-4], ecx       ;保存参数 1<br />                 mov     eax, [ebp-4]       ;参数 1<br />                 add     eax, [ebp-8]       ;加上参数 2<br />                 mov     esp, ebp           ;修正栈<br />                 pop     ebp<br />                 retn<br />        _main<br />                 push    ebp<br />                 mov     ebp, esp<br />                 mov     edx, 14h           ;参数 2给EDX<br />                 mov     ecx, 0Ah           ;参数 1给ECX<br />                 call    @function@8        ;调用函数<br />                 xor     eax, eax<br />                 pop     ebp<br />                 retn<br /><br />    3.__stdcall<br /><br />        _function@8<br />                 push    ebp<br />                 mov     ebp, esp<br />                 mov     eax, [ebp]         ;参数 1<br />                 add     eax, [ebp+C]       ;加上参数 2<br />                 pop     ebp<br />                 retn    8                  ;修复栈<br />        _main<br />                 push    ebp<br />                 mov     ebp, esp<br />                 push    14h                ;参数 2入栈<br />                 push    0Ah                ;参数 1入栈<br />　               call    _function@8　　　　;函数调用<br />                 xor     eax, eax<br />                 pop     ebp<br />                 retn<br /><br />    可见上述三种方法各有各的特点，而且_main必须是__cdecl，一般WIN32的函数都是<br />    __stdcall。而且在Windef.h中有如下的定义：<br /><br />    #define CALLBACK __stdcall<br />    #define WINAPI　 __stdcall</p></blockquote><θθθ>52|