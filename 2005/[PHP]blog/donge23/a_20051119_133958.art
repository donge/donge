<p>作为笔记而言，完全是一种自写自看的行为，本来是没有必要写这篇东西的。但是作为一个生活在网络时代的学生来说，想学好一样东西最好的办法把自己理解的东西放出去，让人讨论，从而，错误得到及时的更正，正确的思想得到肯定，进一步激发深入学习的激情，另外，还可以避免因为成天面对机器而忘记人话是咋说的(还真的差点忘了)，恩，好处多多，何乐不为？</p><p>为什么要学习c语言？对于今天这个惟利是图的世界来说，恐怕初学者第一要问的就这个问题，他们中的很多人都会说在拥有c++，java，c＃这些高级语言的今天，c能做什么呢？在网络中，得到的回答往往是：c无所不能，然后是一些语重心长的说教，呵呵，对于一个对编程知道不多的人来说这样的回答没有任何意义，因此我对这样的问题的回答是：那些高级语言的出现并不能结束c三十年的长盛不衰，c语言没有被任何一种语言所代替，而和c同时代的那些东西。恐怕今天的人连名字都忘了，而在这个世界的每个角落都有无数的编程爱好者和从业人士对c有着无以伦比的狂热。这是事实，这是真理，它证明了一切。无须多言了。<br />毫无疑问没有人能比K&amp;R对c更有发言权了，用他们亲笔所写的《The C Programming Language》来入门是再合适不过了，尽管现在市场上关于c的教材到处都是，但是大半都是以这本书为根基的，严格来说关于c的一切疑问都可以在这本书中得到解释，我的笔记也将以此为本，另外会引入另一本巨作《c专家编程》的观点（强烈向各位有一定c基础的人。推荐此书），为了灵活，这里不作任何约定，在每篇笔记开头会标明笔记内容。</p><p>-----------------------------------------------------------------------------------------<br />笔记范围：《The C Programming Language》第一章</p><p>应该说，算上这次，我应该是第四次读这本书了，每次重读都收获不少。都引起我新的思考，很难想象这本一本技术小书给人留下的感觉是如此深刻，如此令人回味，本章的内容是很容易理解的概念，对于编程学习者是最起码的知识，但是有些东西还是被初学者忽视。以至于在各个技术社区的初学者问题中层出不断。其实这些东西，在第一章就得到了比较完整的解释，下面只是把他们提出来强调一下，</p><p>第一．关于循环终止。在很多书籍中都存在这样的循环语句：</p><p>while ( getchar() != EOF ) &leftsign;….&rightsign;</p><p>很多人不明白这个EOF为何物？具体如何操作？以至于让上面的语句变成了无限循环，呵呵，其实EOF。是文件结束符（end of file），在第七章有说明。其为系统常量。值为-1，当然你在终端输入-1，循环并未结束，why？how to do？恩，你在《c专家编程》里会了解到，c的第一批使用者都是系统设计者和编译器设计者。在他们的理念里，信息往往以文件为单位的。这个标志只是文件结束的状态，一般不由用户提供。而键盘等输入端在os中是个极其特殊的文件。需要用户显式标志文件结束。说是系统常量当然有着系统依赖性，因此不同的系统标志方式就完全不同。Windows下是ctrl+z。linux下是ctrl+D.另外EOF其实不用显式说明。上面的代码与此完全等价：</p><p>while( getchar() ) &leftsign;……&rightsign;<br />(注：后来有读者提出<br />while( getchar() ) &leftsign;&rightsign; <br />和 <br />while( getchar() != EOF ) &leftsign;&rightsign; <br />不是等价的。<br />作者也承认写错了！）</p><p><br />第二．声明和定义。尽管这个问题地球人都知道，但是真正说的清楚的人并不多。有人认为变量的声明和定义没有什么区别。有人认为这个与初始化有关系（我曾经就这样白痴，汗～～～），对于后者那就是根本就不明白这两个概念，声明只是给编译器一个提示，有这么个名字存在于程序中，和运行环境毫无关系。可以重复出现，定义是具体分配内存空间和指定了变量的位子（左值），在同一域中只能出现一次；对于前者的观点。在单文件程序中。几乎找不到错误。但如果你把这样的句子放人头文件，int a；一旦这个头文件被重复包涵。必然出现链接错误。其实这样：<br />extern int a;//声明<br />int a;//定义</p><p>第三．字符数组和字符串。有人认为这两个是同一概念，是这样吗？不，完全不是，前者为容器（数据结构）,后者为数据。这样说也许太理论化，好，我们来改写下那个hello world</p><p>#include &lt;stdio.h&gt;</p><p>#include &lt;stdlib.h&gt;</p><p>int main()</p><p>&leftsign;<br />printf( &quot;\\0hello world &quot; );</p><p>system(&quot;pause&quot;);</p><p>return 0;</p><p>&rightsign;<br />呵呵，什么也没有？是的。还记得字符串是怎么结束的吗？\\0 &quot;\\0hello world &quot;是个常量数组。但是字符串却是“”。字符数组和字符长度是不一样的，</p><p>这章尽管非常简单，但是每个例子都经典之作，你能从代码中学到文字中不能学到的东西。建议你每个都抄一遍，</p><p>-----------------------------------------------------------------------------------------<br /> <br />对《THE C PROGRAMMING LANGUAGE》读书笔记的一点补充 <br />我学习C语言用的也是《THE C PROGRAMMING LANGUAGE》，老实说第一遍学是什么</p><p>也没看懂，觉得不是什么好教材，但是后来读了很多编程的书后才发现，这本书是</p><p>真正的经典，强烈建议所有学习编程语言的人来读，不管你是学Java还是C++。<br />看了CSDN博客上的关于这本书的一篇读书笔记，觉得有一点可以补充的，就写下来</p><p>。<br />关于EOF<br />什么是EOF？<br />EOF就是文件结束的意思，EOF的值是多少？其实在《THE C PROGRAMMING LANGUAGE</p><p>》中作者并没有直接告诉我们，作者说的是:“EOF is an integer defined in </p><p>&lt;stdio.h&gt;,but the specific numeric value doesn\'t matter as long as it is </p><p>not the same as any char value.By using the symbolic constant,we are </p><p>assured that nothing in the program depends on the specific numeric </p><p>value.”<br />如果你确实想知道EOF的值，那么利用练习中提供的程序可以知道你所使用的系统</p><p>是如何规定EOF的。同时也说的很明白:“In our system EOF is -1,but it may </p><p>vary from system to system.That\'s why standard symbolic constants like </p><p>EOF help make your profram portable.”<br />所以简单的说EOF就是-1就没有把EOF的渊源讲清楚。</p><p>-----------------------------------------------------------------------------------------<br /> <br />第二章：</p><p>本章的内容是学习编程中最基础东西，任何一门语言都会告诉你他支持那些数据类型、那些运算、有那些特点、以及有那些不完善的东西。学习这些东西相对来说是单调了点，麻烦了点，但是只有通过了这座迷宫，你才能进入C这个神奇的世界。因此初学者的成功至少有一半来自“耐心”。呵呵，准备好了吗？</p><p>本章的内容还是非常简单的，但是作者的字里行间隐藏了很多重要的信息，不加注意就会从我们的眼皮低下溜了去，下面将一一列出以示强调。</p><p>第一．变量和常量。很多人对于他们的区别很模糊，个人认为他们的主要区别在于是否分配内存空间，换句话说，就是是否存在左值。左值是什么？在第二章的从头到尾好像没找到这个名词，呵呵，你可以在附录中关于变量的条目中找到他，其实就是变量的地址，变量一旦被定义，左值就被确定了，一直到他的生存期结束。我们通常说的变量的值是指变量的右值。这才是我们能操作的对象。根据这个理论，那么就不难知道其实被const修饰的对象不是常量，他有左值，但是这里有个小麻烦，在本章的开头写明了被const修饰的是常量（本章第二段有个（）说明），我查看了原版，并没有这个补充说明，看来应该是译者的理解，在《 C专家编程 》中的一个例子证明了我的想法是正确的，例子如下：</p><p>#include “stdio.h”<br />#include “stdlib.h”<br />#define one 1<br />const int two = 2;<br />int main()<br />&leftsign;<br />    int ix = 1;<br />    switch( ix )<br />    &leftsign;<br />        case one: printf( &quot;this is 1&quot; );/*ok*/ <br />                  break;<br />        case two: printf( &quot;this is 2&quot; );/*error*/ <br />    &rightsign;<br />    system( &quot;pause&quot; );<br />    return 0;<br />&rightsign; <br /> </p><p>大家都知道，case后面只能跟常量表达式，因此被const修饰的变量不是常量，只是变量的右值一般不能改变罢了。另外你也可以从上面感觉出#define和const的区别。</p><p>第二．关于换码序列。这个更多地方叫转义字符，他们大多数是有一些特殊的功能的字符，在上篇笔记中你已经看到了他的一点威力，下面我们再看一段代码：</p><p>#include &quot;stdio.h&quot;<br />#include &quot;string.h&quot;<br />#include &quot;stdlib.h&quot;<br />int main()<br />&leftsign;<br />    int ix;<br />    ix = strlen( &quot;\\0abc&quot; );<br />    printf( &quot;this is %d\\n&quot;, ix );<br />    ix = strlen( &quot;\\007abc&quot; );<br />    printf( &quot;this is %d\\n&quot;, ix );<br />    system( &quot;pause&quot; ); <br />    return 0;<br />&rightsign; </p><p>你会发现，两个差不多的字符串长度完全不一样，什么回事呢？第一个我们可以理解：\\0是字符串结束符，因此其后的任何东西都不能算字符串的内容，因此长度为0。但是第二个呢？我们查了换码序列表就知道‘\\007’这个为一个字符，因此长度为4。这个时候问题来了，编译器为什么没把‘\\007’理解为‘\\0’‘0’‘7’呢？如果这样的话长度也将为0，我们又没人为的加分割符号，呵呵，显然这个和编译器的具体实现相关，凭我们现有知识无法弄明白这点，姑且留着，等待“悟“的一天吧，相信我，这绝对是一种享受。</p><p>第三，关于++运算符，在很多教材上都有个看起来很经典的题目，其代码如下：</p><p>#include &quot;stdio.h&quot;<br />#include &quot;stdlib.h&quot;<br />int main()<br />&leftsign;<br />    int ix, iy;<br />    iy = 1;<br />    ix = ( iy++ ) + ( iy++ ) + ( iy++ );<br />    printf( &quot;this is %d\\n&quot;, ix );<br />    iy = 1;<br />    ix = ( ++iy ) + ( iy++ ) + ( iy++ );<br />    printf( &quot;this is %d\\n&quot;, ix );<br />    iy = 1;<br />    ix = ( ++iy ) + ( ++iy ) + ( iy++ ) ;<br />    printf( &quot;this is %d\\n&quot;, ix );<br />    iy = 1;<br />    ix = ( ++iy ) + ( ++iy ) + ( ++iy ) ;<br />    printf( &quot;this is %d\\n&quot;, ix );<br />    system( &quot;pause&quot; ); <br />    return 0;<br />&rightsign; <br /> </p><p>呵呵，是不是很晕？这个本来无非为了说明先加后加的问题，这个地球人都知道，这里不加说明了，但是这样的程序本身就有很大的问题，编译器的运算并非一定是从左到右的（有些是按树的遍历来算的），因此你会发现不同的编译器结果会不一样，关于这个本章的结尾有很完整的解释，我就不再多说了，总之，这个测试本身就违背了语言的特性。</p><p>-----------------------------------------------------------------------------------------<br />第三章：当好机器的老板</p><p>无论什么时候我们都不该忘记我们是在学一门语言，而学语言的基本要求是：准确无误的用它来表示自己的意图，不仅要让机器读懂，也要让别人（只要他会c语言）读懂你的意思。记住，语言是用来交流的，不论是编程语言还是自然语言。现在让我们对这两个交流的对象分别作个分析，如何才能让他们明白你想干什么，打算怎么干。</p><p>对于机器来说，我们要做的相对要简单点，编程语言的语法比自然语言要简单的多了，一切都由顺序、选择、循环三种结构复合而成，初学者要做的只是走一个“抄写－改写－模仿－习惯”的过程而已。等这些语句成了你的习惯那就太好了，就像你说汉语的时候不会去考虑你用的是陈述句还是感叹句，呵呵，（这个让我想起了我糟糕的英语，汗～～～）。当然我们对机器要做的远远不止这些，让机器读懂这只是第一步而已，如何让机器按照我们的意思运行的更好、更快才是我们要追求的境界，当然，这个境界没有止境。得在经验中慢慢积累，下面只是提出几个个人的建议而已：</p><p>第一． 尽量使用局部变量。因为c语言有个特点，在同个域中的变量必须定义在所有处理语句之前（分程序[o1] 除外），这意味着在程序开始的时候就必须分配好所有的静态空间，而很多数据在程序中用很少，因此我们需要减少这些不必要的开销，灵活运用分程序可以将这些对象进一步局部化，比较下面两段代码：</p><p><br />Code1:<br />  #include &quot;stdio.h&quot;</p><p>#include &quot;stdlib.h&quot;</p><p>int main()</p><p>&leftsign;</p><p>    int ix;</p><p>    char c;</p><p>    scanf( &quot;%c&quot;, &amp;c );</p><p>    if( c == \'y\')</p><p>    &leftsign;</p><p>        ix = 100;</p><p>        printf( &quot;this is %d! \\n&quot;, ix );</p><p>    &rightsign;</p><p>    </p><p>    system( &quot;pause&quot; ); </p><p>      return 0;</p><p>&rightsign;</p><p>Code2</p><p>#include &quot;stdio.h&quot;</p><p>#include &quot;stdlib.h&quot;</p><p>int main()</p><p>&leftsign;    </p><p>    char c;</p><p>    scanf( &quot;%c&quot;, &amp;c );</p><p>    if( c == \'y\')</p><p>    &leftsign;</p><p>        int ix = 100;</p><p>        printf( &quot;this is %d! \\n&quot;, ix );</p><p>    &rightsign;</p><p>    </p><p>    system( &quot;pause&quot; ); </p><p>      return 0;</p><p>&rightsign; <br /> </p><p>你会发现如果我们不输入‘y’系统就没有必要为ix分配空间。</p><p>第二，注意和正视一些看起来像bug的语言特性，比如switch语句，可以说从c语言建立的那天起对他的争论就没有停止过，它的向下穿越给我们带来了不少麻烦。以至于在《c专家编程》的第二章中把它说成是“多做之过“，但是我们发现有时候它的功能还是不可代替的，比如判断一个数是否属于某个离散集合：</p><p><br />#include &quot;stdio.h&quot;</p><p>#include &quot;stdlib.h&quot;</p><p>int main()</p><p>&leftsign;    </p><p>    int i;</p><p>    while( scanf( &quot;%d&quot;, &amp;i ) != EOF )</p><p>    &leftsign;</p><p>        switch( i )</p><p>        &leftsign;</p><p>          case 1: case 2:</p><p>          case 3: case 5:</p><p>          case 8: case 13:</p><p>          printf( &quot;yes!\\n&quot; );</p><p>          break;</p><p>          default :</p><p>          printf( &quot;no!\\n&quot; );</p><p>          break;</p><p>        &rightsign;</p><p>    &rightsign;</p><p>    </p><p>    system( &quot;pause&quot; ); </p><p>      return 0;</p><p>&rightsign; <br /> </p><p><br />呵呵，这个数列大家都熟悉，但是除了switch语句你能找到比他更简洁的表示方法吗？但这正是运用了语句的向下穿越性啊。goto语句也有类似的情况，只要我们仔细研究，这些看起来很麻烦的东西都会变得非常美好。</p><p>好了，对机器的交流我们就说到这儿吧。在下次笔记中我们将谈谈和人的交流－程序的风格问题。</p><p><font color=\"#ffffff\"><font style=\"BACKGROUND-COLOR: #ff0000\">[TAG]</font><br /></font>-----------------------------------------------------------------------------------------</p><p>程序设计初步</p><p>到现在为止，我们已经对语言的基本元素有了个比较完整的了解了，但是总是停留在表达式等细节方面，我们很难写出程序来，在今天任何一个程序都是个工程，如何组织我们已经掌握的这些基本元素，使得他们变成有一点功能的有机整体，这个就需要一个整体观念的设计思想，对于c来说第一步该是过程化程序设计思想，换而言之，就是函数的设计，在上篇文字中我们已经看到了，其核心问题是如何分解要解决的问题，写出各个有独立功能的函数，然后由进入接口函数（在控制台环境下，通常是main函数）组成完整的程序。但是光是这样，我们能解决的问题相当有限，因为在实际应用中，我们要处理的不是那么简单的内置类型（int，char等），而是比这些复杂的多的数据类型，因此第二步该是如何针对具体问题写出抽象模型，即ADT（抽象数据类型），进而实现基于对象的设计思想，而学习指针和结构就需要带着这样的思想去探索，下面将通过一个简单list（链表）的设计来简要的说明一下该如何建立一个完整的程序。</p><p>第一步，建立一个空项目，最好不要选择“控制台程序”模板，这样能使得你的设计思路清楚明白，记住你现在在学习，方便快速不是你该追求的东西。</p><p>第二步，静下心来好好想一想。你的链表要提供那些接口、那些可以给用户修改的部分（如具体的数据类型），这些放在用户可见的list.h文件中。在本文中假设我们提供初始化、销毁、增加节点、删除节点、 插入节点、查找、和打印输出几项功能。那么在上面的工程里加入一个叫llst.h的文件，输入代码如下：</p><p>#ifndef LIST_H</p><p>#define LIST_H</p><p> </p><p>/*定义函数状态*/</p><p>#ifndef ERR</p><p>#define ERR -1</p><p>#define OK 1</p><p>#endif</p><p> </p><p>typedef int status;</p><p>typedef void type; /*用户可以根据具体需要更改此类型*/</p><p> </p><p>typedef struct listitem &leftsign;</p><p>type date; /*节点数据*/</p><p>struct listitem *next; /*指向下个节点*/ </p><p>&rightsign; list_node;//链表节点</p><p>typedef struct &leftsign;</p><p>struct listitem *ptr; /*链表头指针*/</p><p>int size; /*链表长度*/</p><p>&rightsign; list;//链表</p><p> </p><p>list* list_init ( void ); /*初始化*/</p><p>status list_destroy( list* ); /*销毁*/</p><p>status add_node( list*, const type ); /*加入一个节点*/</p><p>status delete_all( list* );//清空</p><p>status delete_node( list*, list_node* ); /*删除一个节点*/</p><p>status insert_node( list*, const type ); /*插入一个节点*/</p><p>list_node* find_node( const list*, const type ); /*查找*/</p><p>status list_print( const list* ); /*打印*/</p><p>#endif</p><p>第三步，在工程中加入list.c文件。Include了上面刚刚建立的头文件，并实现每个极口，由于在通常情况下此文件并不是用户可见（这里把维护等问题除外），所以笔者没加什么注释。当然这个不是什么好习惯，这里过于简单，注释就显得有些多余。</p><p>首先是include需要的头文件：</p><p>#include &quot;stdio.h&quot;</p><p>#include &quot;stdlib.h&quot; </p><p>/*严格来说上面该用尖括号，由于网页显示不得已为之*/ </p><p>#include &quot;list.h&quot;</p><p>接下来是初始化和销毁的实现</p><p>list* list_init ( void )</p><p>&leftsign;</p><p>list *p = ( list* )malloc( sizeof( list ) );</p><p>if( p == 0 )</p><p>return 0;</p><p>p-&gt;ptr = 0; </p><p>p-&gt;size = 0;</p><p>return p;</p><p>&rightsign;</p><p> </p><p>status list_destroy( list *pev )</p><p>&leftsign;</p><p>if( pev == 0 )</p><p>return ERR;</p><p>delete_all( pev );</p><p>free( pev );</p><p>return OK;</p><p>&rightsign;</p><p>按理说，函数不能返回指针，呵呵，这里有个很多初学者都误会的问题，返回局部对象的左值和局部对象的引用(后者是c++中的说法)被返回的确不可以，因为局部对象在函数的活动记录（即函数调用栈中）分配，函数一旦结束局部对象被回收，返回的将是无效地址。因此象下面这样的函数是错误的，</p><p>int* f()</p><p>&leftsign;</p><p>int *p, a;</p><p>p = &amp;a;</p><p>return p;</p><p>&rightsign;</p><p>但是由malloc分配的是堆上分配的，他不会随着函数的结束而被回收。但是这样用要相当小心，必须防止内存泄漏。程序结束前必须free掉该空间。</p><p>下面就是完整的list.c</p><p>#include &quot;stdio.h&quot;</p><p>#include &quot;stdlib.h&quot; </p><p>/*严格来说此处处该用尖括号，由于网页显示不得已为之*/ </p><p>#include &quot;list.h&quot;</p><p>list* list_init ( void )</p><p>&leftsign;</p><p>list *p = ( list* )malloc( sizeof( list ) );</p><p>if( p == 0 )</p><p>return 0;</p><p>p-&gt;ptr = 0; </p><p>p-&gt;size = 0;</p><p>return p;</p><p>&rightsign;</p><p> </p><p>status list_destroy( list *pev )</p><p>&leftsign;</p><p>if( pev == 0 )</p><p>return ERR;</p><p>delete_all( pev );</p><p>free( pev );</p><p>return OK;</p><p>&rightsign;</p><p> </p><p>status add_node( list *p, const type date )</p><p>&leftsign;</p><p>list_node *pev =</p><p>( list_node* )malloc( sizeof( list_node ) );</p><p>if( pev == 0 )</p><p>return ERR;</p><p>pev-&gt;date = date;</p><p>pev-&gt;next = p-&gt;ptr;</p><p>p-&gt;ptr = pev;</p><p>p-&gt;size++;</p><p>return OK;</p><p>&rightsign;</p><p> </p><p>status delete_node( list *p, list_node *pev )</p><p>&leftsign;</p><p>list_node *temp = pev;</p><p>if( pev == 0 )</p><p>return ERR;</p><p>pev = temp-&gt;next;</p><p>free( temp );</p><p>p-&gt;size--;</p><p>return OK;</p><p>&rightsign;</p><p> </p><p>status delete_all( list *pev )</p><p>&leftsign;</p><p>int ix;</p><p>if( pev == 0 )</p><p>return ERR;</p><p>if( pev-&gt;size = 0 )</p><p>return ERR;</p><p>for( ix = 0; ix &lt; pev-&gt;size; ++ix, ++pev-&gt;ptr )</p><p>delete_node( pev, pev-&gt;ptr );</p><p>return OK;</p><p>&rightsign;</p><p>status insert_node( list *p, const type date )</p><p>&leftsign;</p><p>list_node *pev = p-&gt;ptr; ;</p><p>if( p == 0 )</p><p>return ERR;</p><p>pev = find_node( p, date );</p><p>if( pev == 0 )</p><p>&leftsign;</p><p>type ia;</p><p>printf( &quot;输入要插入的数\\n&quot; );</p><p>scanf( &quot;%d&quot;, &amp;ia );</p><p>add_node( p, ia );</p><p>&rightsign;</p><p>else </p><p>&leftsign;</p><p>type ia;</p><p>list_node *pv =</p><p>( list_node* )malloc( sizeof( list_node ) );</p><p>if( pev == 0 )</p><p>return ERR;</p><p>printf( &quot;输入要插入的数\\n&quot; );</p><p>scanf( &quot;%d&quot;, &amp;ia );</p><p>pv-&gt;date = ia;</p><p>pv-&gt;next = pev-&gt;next;</p><p>pev-&gt;next = pv;</p><p>p-&gt;size++;</p><p>&rightsign;</p><p>return OK;</p><p>&rightsign;</p><p> </p><p>list_node* find_node( const list *pev , const type date )</p><p>&leftsign;</p><p>int ix;</p><p>list_node *p = pev-&gt;ptr;</p><p>for( ix = 0; ix &lt; pev-&gt;size; ++ix )</p><p>if( p-&gt;date == date )</p><p>return p;</p><p>else</p><p>p = p-&gt;next;</p><p>return 0;</p><p>&rightsign;<br /></p><p>status list_print( const list *pev )</p><p>&leftsign;</p><p>int ix;</p><p>list_node *p = pev-&gt;ptr;</p><p>if( pev == 0 )</p><p>return ERR;</p><p>if( pev-&gt;size == 0 )</p><p>return OK;</p><p>for( ix = 0; ix &lt; pev-&gt;size; ++ix )</p><p>&leftsign;</p><p>printf( &quot;%d\\t&quot;, p-&gt;date );</p><p>p = p-&gt;next;</p><p>&rightsign;</p><p>printf( &quot;\\n&quot; );</p><p>return OK;</p><p>&rightsign;</p><p>第四步，自己写个main函数，由于个人的调试方式不同，这里不给出代码。只要确保每个函数都能正常工作就行了。</p><p>好了，到现在为止我们把一个数据结构的实现走了一遍。当然，为了简单文字。笔者减少了很多list该有的功能。很多人认为我写太烂，现在再次说明，本文和初学者交流的文字，高手们就不必在这篇文字浪费你的时间了</p><p>-----------------------------------------------------------------------------------------</p><p>尽量利用能利用的资源</p><p>在上篇文字中，我们设计了一个非常简单的list，在设计的过程运用了在本书第五、六章的知识，这些东西是c语言中最难的部分，学术方面的讨论随处可见，指针的用法和特性多得让人无法记住，个人认为最好的方法是多实践，在实践遇到的问题往往就是最常见的、最重要的知识点，至于那些特别的特性，等熟悉了那些常见的后也就不难理解他们了。</p><p>本书的第七。八两章所述的内容严格来说是不属于语言本身的东西，是的，我认为该这么说，这个关系到对”库”的理解，库是什么？是别人已经写好的东西（类型、函数、常量等等），我们的程序可以根据他们提供的接口调用就可，以节省我们开发的时间和精力，但是必须明白，不是没有库，我们就不能写东西了。第八章的内容就是告诉我们如何根据具体的os写出类似标准的io库，是的，库必须是系统相关的，当然你可以最大限度的保证他的可移植性（这正是标准库的成功之处）。</p><p>当然，对于大多数程序开发而言，库的运用可能是程序设计水平高低的最重要的指标之一，没有人会笨到放着的东西不用，而化费大量的时间去自己写一个（当然作为学习研究则正好相反）。有一次，一个网友跟我说标准c++和c怎么也干不了，当我提出反对意见时，此人气势汹汹的质问：“你不用WIN API写个窗体给我看看！？”。我无言了，因为要说的太多了， 比如：难道API是凭空出现的吗？难道我写不出API就可以说c++和c无此能力吗？我无此荣幸，就算有，也不是片刻就可以拿出来给他证明的。因此我选择沉默，人类的任何成功都是建立在前人的基础上的，这样才有我们引以为傲的效率。</p><p>回到正题，标准库非常庞大(别的也小不到那去)，os的系统调用也很多，对于这些我的建议是：记住常用的，别的用到的时候查手册之类的东西即可，比如，以c标准库为例，在本书附录B中提到的大多都需要记住。至于别的，大家可以去看看《c语言参考手册》。<br /></p><θθθ>78|